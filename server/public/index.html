<!DOCTYPE html>
<html>
<head>
  <title>WebRTC Learning Mode</title>
</head>
<body>
  <h2>WebRTC File Share (Learning Mode)</h2>

  <button id="createBtn">Create Room</button>
  <br><br>

  <input id="roomInput" placeholder="Enter Room ID" />
  <button id="joinBtn">Join Room</button>

  <h3 id="roomDisplay"></h3>

  <div id="mainSection" style="display:none;">
    <hr>

    <h4>Chat</h4>
    <input id="messageInput" placeholder="Type message..." />
    <button id="sendBtn">Send</button>
    <ul id="messages"></ul>

    <hr>

    <h4>File Transfer</h4>
    <input type="file" id="fileInput" />
    <button id="sendFileBtn">Send File</button>

    <br><br>

    <progress id="progressBar" value="0" max="100" style="width:300px;"></progress>
    <p id="progressText"></p>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let currentRoom = null;
    let peerConnection;
    let dataChannel;

    const config = {
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    };

    // ---- ROOM BUTTONS ----
    document.getElementById("createBtn").onclick = () => {
      socket.emit("create-room");
    };

    document.getElementById("joinBtn").onclick = () => {
      const roomId = document.getElementById("roomInput").value;
      socket.emit("join-room", roomId);
    };

    document.getElementById("sendBtn").onclick = () => {
      const input = document.getElementById("messageInput");
      socket.emit("room-message", {
        roomId: currentRoom,
        message: input.value
      });
      input.value = "";
    };

    socket.on("room-created", (roomId) => {
      currentRoom = roomId;
      document.getElementById("roomDisplay").innerText = "Room: " + roomId;
      document.getElementById("mainSection").style.display = "block";
      setupPeer(true);
    });

    socket.on("room-joined", (roomId) => {
      currentRoom = roomId;
      document.getElementById("roomDisplay").innerText = "Joined: " + roomId;
      document.getElementById("mainSection").style.display = "block";
      setupPeer(false);
    });

    socket.on("room-message", (msg) => {
      const li = document.createElement("li");
      li.innerText = msg;
      document.getElementById("messages").appendChild(li);
    });

    socket.on("peer-joined", async () => {
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      socket.emit("signal", {
        roomId: currentRoom,
        data: { offer }
      });
    });

    socket.on("signal", async (data) => {
      if (data.offer) {
        await peerConnection.setRemoteDescription(data.offer);
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        socket.emit("signal", {
          roomId: currentRoom,
          data: { answer }
        });
      } else if (data.answer) {
        await peerConnection.setRemoteDescription(data.answer);
      } else if (data.candidate) {
        await peerConnection.addIceCandidate(data.candidate);
      }
    });

    socket.on("error-message", alert);

    // ---- WEBRTC SETUP ----
    function setupPeer(isInitiator) {
      peerConnection = new RTCPeerConnection(config);

      if (isInitiator) {
        dataChannel = peerConnection.createDataChannel("file");
        setupDataChannel();
      } else {
        peerConnection.ondatachannel = (event) => {
          dataChannel = event.channel;
          setupDataChannel();
        };
      }

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit("signal", {
            roomId: currentRoom,
            data: { candidate: event.candidate }
          });
        }
      };
    }

    function setupDataChannel() {
      dataChannel.binaryType = "arraybuffer";

      let receivedBuffers = [];
      let receivedSize = 0;
      let fileSize = 0;
      let fileName = "";
      let startTime = Date.now();

      dataChannel.onmessage = (event) => {
        if (typeof event.data === "string") {
          const meta = JSON.parse(event.data);
          fileSize = meta.size;
          fileName = meta.name;
          startTime = Date.now();
          return;
        }

        receivedBuffers.push(event.data);
        receivedSize += event.data.byteLength;

        const percent = Math.floor((receivedSize / fileSize) * 100);
        const seconds = (Date.now() - startTime) / 1000;
        const speed = (receivedSize / 1024 / 1024 / seconds).toFixed(2);

        document.getElementById("progressBar").value = percent;
        document.getElementById("progressText").innerText =
          `Download: ${percent}% (${speed} MB/s)`;

        if (receivedSize === fileSize) {
          const blob = new Blob(receivedBuffers);
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = fileName;
          link.click();

          document.getElementById("progressText").innerText =
            "Download Complete âœ…";
        }
      };
    }

    // ---- FILE SEND ----
    document.getElementById("sendFileBtn").onclick = async () => {
      const file = document.getElementById("fileInput").files[0];
      if (!file) return;

      dataChannel.send(JSON.stringify({
        name: file.name,
        size: file.size
      }));

      const chunkSize = 64 * 1024;
      let offset = 0;
      const reader = new FileReader();
      const startTime = Date.now();

      reader.onload = async (e) => {
        while (dataChannel.bufferedAmount > 4 * 1024 * 1024) {
          await new Promise(r => setTimeout(r, 50));
        }

        dataChannel.send(e.target.result);
        offset += e.target.result.byteLength;

        const percent = Math.floor((offset / file.size) * 100);
        const seconds = (Date.now() - startTime) / 1000;
        const speed = (offset / 1024 / 1024 / seconds).toFixed(2);

        document.getElementById("progressBar").value = percent;
        document.getElementById("progressText").innerText =
          `Upload: ${percent}% (${speed} MB/s)`;

        if (offset < file.size) {
          readSlice(offset);
        }
      };

      function readSlice(o) {
        const slice = file.slice(o, o + chunkSize);
        reader.readAsArrayBuffer(slice);
      }

      readSlice(0);
    };
  </script>
</body>
</html>
