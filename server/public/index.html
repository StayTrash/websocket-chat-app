<!DOCTYPE html>
<html>
<head>
  <title>WebRTC File Share</title>
</head>
<body>
  <h2>AirDrop Style File Share</h2>

  <button onclick="createRoom()">Create Room</button>
  <br><br>

  <input id="roomInput" placeholder="Enter Room ID" />
  <button onclick="joinRoom()">Join Room</button>

  <h3 id="roomDisplay"></h3>

  <div id="fileSection" style="display:none;">
    <input type="file" id="fileInput" />
    <button onclick="sendFile()">Send File</button>

    <br><br>

    <progress id="progressBar" value="0" max="100" style="width:300px;"></progress>
    <p id="progressText"></p>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let currentRoom = null;
    let peerConnection;
    let dataChannel;

    const config = {
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    };

    function createPeer(isInitiator) {
      peerConnection = new RTCPeerConnection(config);

      if (isInitiator) {
        dataChannel = peerConnection.createDataChannel("file");
        setupDataChannel();
      } else {
        peerConnection.ondatachannel = (event) => {
          dataChannel = event.channel;
          setupDataChannel();
        };
      }

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit("signal", {
            roomId: currentRoom,
            data: { candidate: event.candidate }
          });
        }
      };
    }

    function setupDataChannel() {
      let receivedBuffers = [];
      let receivedSize = 0;
      let fileSize = 0;
      let fileName = "";

      dataChannel.onmessage = (event) => {
        if (typeof event.data === "string") {
          const meta = JSON.parse(event.data);
          fileSize = meta.size;
          fileName = meta.name;
          return;
        }

        receivedBuffers.push(event.data);
        receivedSize += event.data.byteLength;

        const percent = Math.floor((receivedSize / fileSize) * 100);
        document.getElementById("progressBar").value = percent;
        document.getElementById("progressText").innerText =
          "Download: " + percent + "%";

        if (receivedSize === fileSize) {
          const blob = new Blob(receivedBuffers);
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = fileName;
          link.click();

          document.getElementById("progressText").innerText =
            "Download Complete âœ…";
        }
      };
    }

    async function createRoom() {
      socket.emit("create-room");
    }

    async function joinRoom() {
      const roomId = document.getElementById("roomInput").value;
      socket.emit("join-room", roomId);
    }

    socket.on("room-created", (roomId) => {
      currentRoom = roomId;
      document.getElementById("roomDisplay").innerText =
        "Room ID: " + roomId;
      document.getElementById("fileSection").style.display = "block";
      createPeer(true);
    });

    socket.on("room-joined", (roomId) => {
      currentRoom = roomId;
      document.getElementById("roomDisplay").innerText =
        "Joined: " + roomId;
      document.getElementById("fileSection").style.display = "block";
      createPeer(false);
    });

    socket.on("peer-joined", async () => {
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      socket.emit("signal", {
        roomId: currentRoom,
        data: { offer }
      });
    });

    socket.on("signal", async (data) => {
      if (data.offer) {
        await peerConnection.setRemoteDescription(
          new RTCSessionDescription(data.offer)
        );

        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        socket.emit("signal", {
          roomId: currentRoom,
          data: { answer }
        });
      } else if (data.answer) {
        await peerConnection.setRemoteDescription(
          new RTCSessionDescription(data.answer)
        );
      } else if (data.candidate) {
        await peerConnection.addIceCandidate(
          new RTCIceCandidate(data.candidate)
        );
      }
    });

    function sendFile() {
      const file = document.getElementById("fileInput").files[0];
      if (!file) return;

      dataChannel.send(
        JSON.stringify({ name: file.name, size: file.size })
      );

      const chunkSize = 64 * 1024;
      let offset = 0;
      const reader = new FileReader();

      reader.onload = (e) => {
        dataChannel.send(e.target.result);

        offset += e.target.result.byteLength;
        const percent = Math.floor((offset / file.size) * 100);

        document.getElementById("progressBar").value = percent;
        document.getElementById("progressText").innerText =
          "Upload: " + percent + "%";

        if (offset < file.size) {
          readSlice(offset);
        }
      };

      function readSlice(o) {
        const slice = file.slice(o, o + chunkSize);
        reader.readAsArrayBuffer(slice);
      }

      readSlice(0);
    }
  </script>
</body>
</html>
